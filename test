package uk.ac.ed.inf.powergrab;

import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;
import java.util.Set;

import com.mapbox.geojson.Feature;
import com.mapbox.geojson.FeatureCollection;
import com.mapbox.geojson.LineString;
import com.mapbox.geojson.Point;


abstract public class Drone { 
	public  Position currentPos; // lon, lat
	public Integer movesLeft; // count the number of moves made
	public  Double coins; // count coins
	public  Double power; // keep track of power
	public Integer seed;
	public  List <ChargingStation> Stations;
	public  String textfile;

	public ArrayList<Point> movesHistory = new ArrayList<Point>();
	public ArrayList<Double> coinsHistory = new ArrayList<Double>();
	public ArrayList<Double> powerHistory = new ArrayList<Double>();
	public ArrayList<Direction> directionHistory = new ArrayList<Direction>();

	//public List<ChargingStation> goodStations_List = goodStations(Stations);

	// constructors 
	
	public Drone(Position currentPos, Double coins, Double power, Integer seed, List <ChargingStation> Stations, String textfile) {	
		this.currentPos = currentPos;
		this.movesLeft = 250;
		this.coins = 0.0;
		this.power = 250.0;
		this.seed = seed;
		this.Stations = Stations;
		this.textfile = textfile;
		//this.movesHistory.add(currentPos);
	}

	// getters
	public Position getCurrentPos() { return currentPos;}
	public Integer getMovesLeft() { return this.movesLeft;}
	public double getCoins() { return this.coins;}
	public double getPower() { return this.power;}
	public Integer getSeed() { return this.seed;}
	public List <ChargingStation> getStations() { return this.Stations;}
	public String getTextfile() { return this.textfile;}
	public ArrayList<Point> getMovesHistory() { return this.movesHistory;}
	
	
	// setters
	protected void setCurrentPos(Position currentPos) { this.currentPos = currentPos;}
	protected void setMoves(Integer moves) {this.movesLeft = movesLeft;}
	protected void setCoins(Double coins) { this.coins = coins;}
	protected void setPower(Double power) { this.power = power;}
	protected void setSeed(Integer seed) {this.seed = seed;}
	protected void setStations(List <ChargingStation> Stations) {this.Stations = Stations;}
	protected void setTextfile(String textfile) {this.textfile = textfile;}
	protected void setMovesHistory(ArrayList <Point> movesHistory) {this.movesHistory = movesHistory;}
	
	// check if drone is within play area
	protected boolean inPlayArea() { return getCurrentPos().inPlayArea();}

	protected Point getPointOfDirection(Direction d, Double lat, Double lon) {
		// lat lon of the current position
		Position initPos = new Position(lat, lon);
		System.out.print(d);
		Point i = convertToPoint(initPos);
		System.out.println(i);

		Position direction_pos = initPos.nextPosition(d);
		Point direction_point = convertToPoint(direction_pos);
		
		System.out.println(direction_point);

	return direction_point;
	}
	

	protected void directionDecision(Double lat, Double lon) throws IOException {
		//for each direction
		ChargingStation maxFeat = null;
		HashMap <Direction, ChargingStation> directionCharging = new HashMap <Direction, ChargingStation>();
		Double maxCoins = 0.0;
		//List<ChargingStation> goodStations_List = goodStations(Stations);
		List <Direction> arr = null;
		// Loop through the 16 directions
		int index =0; 
		//System.out.print(Direction.values().length);
		
		for (Direction d : Direction.values()) {
			
			// get position of direction d given current position
			Point direction_point = getPointOfDirection(d, lat, lon);
			// find nearest (good) stations from that d 
			findGoodNearestStations(directionCharging, d, direction_point);	
		}
		
		System.out.print(directionCharging);
		
		HashMap<Direction,ChargingStation> hm= findMaxCoinsStation(directionCharging, maxCoins);
		String direction_set = hm.keySet().toString();
		Set<Direction> dir = hm.keySet(); //direction to take
		arr = new ArrayList<Direction>(dir);
		Direction direct = arr.get(0);						
		maxFeat =  hm.get(direct); // max charging station
		//System.out.print(maxFeat);
		if (arr.equals(null)) { //not empty
			System.out.println("move drone");
			//System.out.print(arr=arr.);

			moveDrone(arr.get(0), maxFeat); // move to random direction that has charging stations nearby
			updateStation(maxFeat);
		} else {
			System.out.println("random");
			moveDroneRandomly(seed); // move randomly
		}
	}
	
	
	protected void findGoodNearestStations(HashMap <Direction, ChargingStation> directionCharging, Direction d, Point direction_point) {
		List<ChargingStation> goodStations_List = goodStations();
		int count =0;
		// for each good charging station, get station point, check range (directionCharging)
		for (ChargingStation f: goodStations_List) {
			Point station_point = convertToPoint(Stations.get(count).pos);
			//System.out.println(getRange(direction_point, station_point));
			
			if(getRange(direction_point, station_point) < 0.00025) {
				//System.out.print("HHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII");
				//System.out.println(getRange(direction_point, station_point));
				//directionCharging.put(d, f);
				count = count + 1;
			}
		}
	}
	

	protected List<ChargingStation> goodStations(){
		List<ChargingStation> goodStations_List = new ArrayList <ChargingStation>();
		for (ChargingStation f: Stations) {
			if (ChargingStation.get_marker(f).contains("lighthouse")) {
				goodStations_List.add(f);
				System.out.println(f);
			}
		}
		return goodStations_List;	
	}
	
	protected List<ChargingStation> badStations(){
		List<ChargingStation> badStations_List = new ArrayList <ChargingStation>();
		for (ChargingStation f: Stations) {
			if (ChargingStation.get_marker(f).contains("danger")) {
				badStations_List.add(f);
				System.out.println(f);
			}
		}
		return badStations_List;	
	}
	
	
	// Picks direction bases on Direction with station with max coins
	protected HashMap <Direction, ChargingStation>findMaxCoinsStation(HashMap <Direction, ChargingStation>  directionCharging, Double maxCoins) {
		ChargingStation maxFeat = null;
		Direction maxDirection = null;
		for (Map.Entry<Direction, ChargingStation> entry: directionCharging.entrySet()) {
			Direction d = entry.getKey();
			//System.out.println(d);
			ChargingStation f = entry.getValue();
			//System.out.print(Stations.get(1).coins);
			//System.out.println(f.coins);
		
			Double station_coins = ChargingStation.get_coins(f);
			//System.out.println(station_coins);

			// find max coins
			if (maxCoins < station_coins) {
				//System.out.println(maxCoins);
				maxCoins = station_coins;
				maxFeat = f;
				maxDirection = d;

			}
		}
		
		HashMap<Direction,ChargingStation> hm=new HashMap<>();
	    hm.put(maxDirection, maxFeat);
	    //System.out.print(hm);
		return hm;
	}

	
	protected Point convertToPoint(Position pos) {
		return (Point) Point.fromLngLat(pos.longitude, pos.latitude);
	}
	
	protected Double getRange(Point direction_point, Point station_point) {
		Double dist,x,y;
		x = direction_point.latitude()-station_point.latitude();
		y = direction_point.longitude()-station_point.longitude();
		return Math.sqrt(Math.pow(x,2) + Math.pow(y,2));
	}
	
	
	protected Double getDist(Point point) {
		Double dist,x,y;
		x = point.latitude()-getCurrentPos().latitude;
		y = point.longitude()-getCurrentPos().longitude;
		dist = Math.sqrt(Math.pow(x,2) + Math.pow(y,2));
		return dist;
	}
	
	// move drone to nearby charging station
	protected void moveDrone(Direction d, ChargingStation maxFeat) throws IOException { 
		Position curr_Pos = getCurrentPos();
		Point direction_point = getPointOfDirection(d, curr_Pos.latitude, curr_Pos.longitude);
		
		Double total_power = this.power + ChargingStation.get_power(maxFeat);
		this.power = this.power + total_power;
		Double total_coins = this.coins + ChargingStation.get_coins(maxFeat);
		this.coins = this.coins + total_coins;

		updateDrone(curr_Pos, d);
		// initialise prev position as new position 
		Position new_pos = new Position (direction_point.longitude(), direction_point.latitude());
		setCurrentPos(new_pos);

		//updateStation(maxFeat);
		//update station
		Double st_coins, st_power =0.0;
		
		if (ChargingStation.get_coins(maxFeat) > 0){
			st_coins =0.0;
		} else{
			st_coins =ChargingStation.get_coins(maxFeat) + this.coins;
		}
		
		if (ChargingStation.get_power(maxFeat) >0) {
			st_power = 0.0;
		}else {
			st_power = ChargingStation.get_power(maxFeat) + this.power;
		}
		maxFeat.setCoins(maxFeat, st_coins);
		maxFeat.setPower(maxFeat, st_power);

		
		//writeToTextFile(curr_Pos,d, new_pos, textfile);
	}
	
	protected void updateDrone(Position curr_Pos, Direction d) {
		this.movesLeft = getMovesLeft()-1;
		System.out.println(this.movesLeft);

		this.power = getPower()-1.25;
		System.out.print(this.power);
				
		movesHistory.add(convertToPoint(curr_Pos));
		directionHistory.add(d);
		powerHistory.add(this.power);
		coinsHistory.add(this.coins);
	}
	

	
	// move drone randomly (no good charging station nearby)
	protected void moveDroneRandomly(Integer seed) {
		HashMap <Direction, ChargingStation> directionCharging = new HashMap <Direction, ChargingStation>();
		Position curr_Pos = getCurrentPos();
		// randomly generate direction d
		Direction d = getRandomDirection(seed);
		Point direction_point = getPointOfDirection(d, curr_Pos.latitude, curr_Pos.longitude);
		updateDrone(curr_Pos, d);

		// initialise prev position as new position 
		Position new_pos = new Position (direction_point.longitude(), direction_point.latitude());
		Point n = convertToPoint(new_pos);
		Point a = convertToPoint(getCurrentPos());

		setCurrentPos(new_pos);
		Point b = convertToPoint(getCurrentPos());

		
	}

		

	public static Direction getRandomDirection(Integer seed) {
	    Random random = new Random(seed);
	    int i = random.nextInt(16);
	    return Arrays.asList(Direction.values()).get(i);
	}
	
	// add/subtract power and coins for charging station
	protected void updateStation(ChargingStation maxFeat) { 
		Point point;
		Double dist;
		
		// subtract maxFeat coins from charging station coins
		//Double d = Double.parseDouble(ChargingStation.get_coins(maxFeat));
		//Stations
		//maxFeat.setCoins(maxFeat, st_coins);
		// set new coins and power of station to 0
		//c.setCoins(maxFeat, 0.0);
		//c.setPower(maxFeat, 0.0);
		
	}
	

	

	// finished moves
	public boolean isFinished() { return (this.movesLeft == 0) || (this.power < 1.25);}
	
	
	protected void writeToTextFile(Position curr_Pos, Direction d, Position new_pos, String textfile) throws IOException {
		//55.944425,-3.188396,SSE,55.944147836140246,-3.1882811949702905,0.0,248.75
		//before_lat, before_lon, dir, after_lat, after_lon, Drone_coins, Drone_power
		Double prev_lat = curr_Pos.latitude;
		Double prev_lon = curr_Pos.longitude;
		
		Double next_lat = new_pos.latitude;
		Double next_lon = new_pos.longitude;
		
		Double coins = this.coins;
		Double power = this.power;
		String list [] = new String[] {prev_lat.toString(), prev_lon.toString(), d.toString(), next_lat.toString(), next_lon.toString(), coins.toString(), power.toString()};
		List<String> movesList = Arrays.asList(list);
		
		
		Path file = Paths.get(textfile);
		Files.write(file, movesList, StandardCharsets.UTF_8);
		//System.out.print(textfile);
		//PrintWriter writer = new PrintWriter("the-file-name.txt", "UTF-8");
		//writer.println("The first line");
		//writer.close();
	}
	/*
	public LineString getPath(Point p) {
		// test from left top corner to right bottom corner
		List<Point> points_for_path =new ArrayList<Point>();
		while(!isFinished() && inPlayArea()) {
			// position p from choose move
			
			points.add(Point.fromLngLat(p.longitude, p.latitude));
			moveDrone(p);
			updateStats();
			System.out.println("moves: " + !isFinished() + "   area: " + inPlayArea());
		}
		
		returnLineString.fromLngLats(points);
			
	}*/
}

